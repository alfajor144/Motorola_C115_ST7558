/***************************************************
  This is a library for the ST7558 i2c display.

  These displays use IÂ²C to communicate, 2 or 3 pins are required to
  interface (RST is optional)
  
  Based on the driver written by Limor Fried/Ladyada for Adafruit Industries.
  MIT license, all text above must be included in any redistribution

  It depends on libraries Adafruit-GFX

  Author: Tapia Favio: technicc(at)gmail.com
 
 Pinout:
 
	Lcd chip: ST7558 - Wintek Lcd
	Resolution: 94x64
	Technology: FSTN
	I2C write address: 0x78 - (0c3C with Wire arduino funtion)

    Pin1 Vdd +2.8V		+-----------------------------+
    Pin2 Res (n/c)		|                             |
    Pin3 Sclk			|        Motorola C115        |
    Pin4 Sda 			|            102x65           |
    Pin5 A0 (Gnd)		|       (visible 94x64)       |
    Pin6 Gnd			+-----------------------------+
    Pin7 Vlcd +12V		     |  |  |  |  |  |  |  |
    Pin8 Reset			     1  2  3  4  5  6  7  8 

 ****************************************************/

#if defined(ARDUINO) && ARDUINO >= 100
  #include "Arduino.h"
#else
  #include "WProgram.h"
#endif

#ifdef __AVR__
  #include <util/delay.h>
#endif

#ifndef _BV
  #define _BV(x) (1 << (x))
#endif

#include <string.h>
#include <avr/pgmspace.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include "ST7558.h"

 
// the memory buffer for the LCD
uint8_t st7558_buffer[]={
  /* page 0 (lines 0-7) */
  0x00,0x00,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xf0,0x80,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,
  0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0xfe,0xfe,0xfe,0xfe,0xfe,0xfe,
  0xfe,0xfe,0xfe,0xfe,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  
  /* page 1 (lines 8-15) */
  0x00,0x00,0x00,0x07,0x1f,0x7f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0xf8,
  0xf0,0xe0,0xe0,0xc0,0x80,0x80,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
  0xff,0xc0,0xc0,0xc0,0xe0,0xf0,0xf8,0xfc,0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
  0xff,0x7f,0x1f,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  
  /* page 2 (lines 16-23) */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x07,0x0f,0x0f,0x1f,0x3f,0x3f,0x7f,0x7f,
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x7f,0x3f,0x3f,0x1f,0x1f,0x0f,0x07,0x03,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  
  /* page 3 (lines 24-31) */
  0x00,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,
  0xfc,0xfc,0xfd,0xfd,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
  0xff,0xff,0xff,0xfd,0xfd,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,
  0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0x00,0xfc,0xfc,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,
  0xfc,0xfc,0xfc,0x00,0x00,0x0c,0x0c,0x0c,0x0c,0xfc,0xfc,0xfc,0x0c,0x0c,0x0c,0x0c,
  0x00,0x00,0x00,0xfc,0xfc,0xfc,0x7c,0xf8,0xe0,0x80,0x00,0x00,0xfc,0xfc,0xfc,0x00,
  
  /* page 4 (lines 32-39) */
  0x00,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,
  0x1f,0x9f,0x9f,0x9f,0xdf,0xdf,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
  0xff,0xdf,0xdf,0x9f,0x9f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,
  0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x00,0x1f,0x3f,0x7f,0x78,0x70,0x60,0x60,0x70,0x78,
  0x7f,0x3f,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x7f,0x7f,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x7f,0x7f,0x7f,0x00,0x01,0x07,0x0f,0x3f,0x7c,0x7f,0x7f,0x7f,0x00,
  
  /* page 5 (lines 40-47) */
  0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0xc0,0xe0,0xf0,0xf8,0xfc,0xfc,0xfe,0xff,
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0xfc,0xfc,0xf8,0xf0,0xe0,0xc0,0x80,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  
  /* page 6 (lines 48-55) */
  0x00,0x00,0x00,0xe0,0xf8,0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x7f,0x3f,
  0x1f,0x0f,0x07,0x03,0x03,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
  0xff,0x01,0x01,0x03,0x03,0x07,0x0f,0x1f,0x3f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
  0xff,0xfe,0xf8,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  
  /* page 7 (lines 56-63) */
  0x00,0x00,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x01,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,
  0x7f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x7f,0x7f,0x7f,0x7f,0x7f,
  0x7f,0x7f,0x7f,0x7f,0x7f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  
  /* page 8 (lines 64-71) */
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

#define enablePartialUpdate

#ifdef enablePartialUpdate
static uint8_t xUpdateMin, xUpdateMax, yUpdateMin, yUpdateMax;
#endif



static void updateBoundingBox(uint8_t xmin, uint8_t ymin, uint8_t xmax, uint8_t ymax) {
#ifdef enablePartialUpdate
  if (xmin < xUpdateMin) xUpdateMin = xmin;
  if (xmax > xUpdateMax) xUpdateMax = xmax;
  if (ymin < yUpdateMin) yUpdateMin = ymin;
  if (ymax > yUpdateMax) yUpdateMax = ymax;
#endif
}

ST7558::ST7558(uint8_t rst)
 : Adafruit_GFX(ST7558_WIDTH, ST7558_HEIGHT)
{
  _rst  = rst;
}

inline void ST7558::i2cwrite(uint8_t *data, uint8_t len) {
        
  Wire.beginTransmission(I2C_ADDR_DISPLAY);
  Wire.write(data, len);
  Wire.endTransmission();

}

void ST7558::hwReset(void){
  
  if (_rst) {
    pinMode(_rst, OUTPUT);
    digitalWrite(_rst, HIGH);
    delay(500);
    digitalWrite(_rst, LOW);
    delay(500);
    digitalWrite(_rst, HIGH);
    delay(500);
  }
}
  
static uint8_t cmd_init[]= {CONTROL_RS_CMD, // Bit de Control A0=0
                            0x2E,           // MXMY
                            0x21,           // Extend Set H=1
                            0x12,           // Bias
                            0xC0,           // VOP
                            0x0B,           // Boost
                            0x20,           // Normal Set H=0
                            0x11,           // PRS
                            0x00,           // nop
                            0x40,           // Y addr
                            0x80,           // X addr
                           },
               cmd_invert[]= {CONTROL_RS_CMD, 0x20, 0x0D},
               cmd_on[]= {CONTROL_RS_CMD, 0x20, 0x0C},
               cmd_off[]= {CONTROL_RS_CMD, 0x20, 0x08};

void ST7558::init(void) {
  Wire.begin();
  
  colstart= 0x80;
  rowstart= 0x40;
  
  hwReset();
  
  i2cwrite(cmd_init, sizeof(cmd_init));
  
  // set up a bounding box for screen updates
  updateBoundingBox(0, 0, _width-1, _height-1);
  
}

void ST7558::setContrast(uint8_t val) {
    
  if (val > 0x7f) {
    val = 0x7f;
  }
  
  uint8_t cmd[]={CONTROL_RS_CMD, 
                 ST7558_FUNCTIONSET | ST7558_EXTENDEDINSTRUCTION, 
                 ST7558_SETVOP | val, 
                 ST7558_FUNCTIONSET
  };

  i2cwrite(cmd, sizeof(cmd));
  
}

// clear everything
void ST7558::clearDisplay(void) {
  memset(st7558_buffer, 0, sizeof(st7558_buffer));
  updateBoundingBox(0, 0, _width-1, _height-1);
  cursor_y = cursor_x = 0;
}

void ST7558::display(void) {
  uint8_t col, maxcol, p, maxPages;
  uint8_t buff[17], i;
  
  maxPages=uint8_t(1+(_height-1)/8) ;
  buff[0]= CONTROL_RS_RAM;
  
  //for(p = 0; p < _height/8; p++) {
  for(p = 0; p < maxPages; p++) {
#ifdef enablePartialUpdate
    // check if this page is part of update
    if ( yUpdateMin >= ((p+1)*8) ) {
      continue;   // nope, skip it!
    }
    if (yUpdateMax < p*8) {
      break;
    }
#endif

#ifdef enablePartialUpdate
    col = xUpdateMin;
    maxcol = xUpdateMax;
#else
    // start at the beginning of the row
    col = 0;
    maxcol = _width-1;
#endif
    
    setAddrXY(col, p);
    
    while(col<= maxcol ){
      for(i=1; (i<17)&&(col<= maxcol); i++,col++)
        buff[i]=st7558_buffer[(_width*p)+col];
      i2cwrite(buff, i);
    }
  }
  
  displayOn();
  
  setAddrXY(0, 0);

#ifdef enablePartialUpdate
  xUpdateMin = _width - 1;
  xUpdateMax = 0;
  yUpdateMin = _height-1;
  yUpdateMax = 0;
#endif

}

void ST7558::drawPixel(int16_t x, int16_t y,  uint16_t color) {
  
  if((x < 0) ||(x >= _width) || (y < 0) || (y >= _height))
    return;
   
  int16_t t;
  switch(rotation){
    case 1:
      t = x;
      x = y;
      y =  _height - 1 - t;
      break;
    case 2:
      x = _width - 1 - x;
      y = _height - 1 - y;
      break;
    case 3:
      t = x;
      x = _width - 1 - y;
      y = t;
      break;
  }

  if ((x < 0) || (x >= _width) || (y < 0) || (y >= _height))
    return;

  // x is which column
  if (color) 
    st7558_buffer[x+ (y/8)*_width] |= _BV(y%8);  
  else
    st7558_buffer[x+ (y/8)*_width] &= ~_BV(y%8); 
  
  updateBoundingBox(x,y,x,y);
}

uint8_t ST7558::getPixel(int8_t x, int8_t y) {
  if ((x < 0) || (x >= _width) || (y < 0) || (y >= _height))
    return 0;

  return (st7558_buffer[x+ (y/8)*_width] >> (y%8)) & 0x1;  
}

uint8_t ST7558::getPixel(int8_t x, int8_t y, const uint8_t *bitmap, uint8_t w, uint8_t h) {
  if ((x < 0) || (x >= w) || (y < 0) || (y >= h))
    return 0;

  return (pgm_read_byte(bitmap + (y/8)*w + x) >> (y%8)) & 0x1;  
}

void ST7558::displayOff(void){

  i2cwrite(cmd_off, sizeof(cmd_off));
}
void ST7558::displayOn(void){
  i2cwrite(cmd_on,sizeof(cmd_on));
}

void ST7558::setAddrXY(uint8_t x, uint8_t y){

  uint8_t cmdXY[]={CONTROL_RS_CMD, 0x20, colstart+x, rowstart+y};  
  
  i2cwrite( cmdXY, sizeof(cmdXY) );
}

void ST7558::invertDisplay(boolean i){
   
   if(i==true)
     i2cwrite(cmd_invert, sizeof(cmd_invert));
   else if(i==false)
     i2cwrite(cmd_on, sizeof(cmd_on));
}
